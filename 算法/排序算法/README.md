# 排序

排序是将所有无需的序列标称有序的序列
  * 将列表元素从无序变成有序
  * 排列标中的元素，使表中元素满足按关键字递增或递减
  自然语言描述：

   输入n个记录 R1、R2....Rn 对应的关键字为K1、K2....Kn
   输出R1'、R2'....Rn' 对应的关键字为K1<=K2<=....Kn 
  
**排序算法稳定性**

   若待排序表中有两个元素Ri和Rj,对应的关键字是ki=kj ,且在排序前，Ri在Rj的前面，使用某个排序算法后，Ri仍然在Rj的前面，就成这个算法是稳定的，否则是不稳定的。
   
   待排序的记录序列中，存在多个具有相同的关键字的记录，经过排序，这些记录的相对次序保持不变。
   
   算法稳定性是衡量算法的性质，而不是衡量一个算法的优劣
 
```
  如排序 [1,4,7,3,2,1] 初始存在相同的带排序序列 第一个位置为a,最后一个位置的1为b,在排序完成后，可能存在的排序序列
 l1=  [a,b,2,3,4,7] 或者 l2= [b,a,2,3,4,5] 而l2排序后，b相对于a的初始位置发生了变化，因此是不稳定排序
  
```
## 内部排序和外部排序

 * 内部排序：指在排序期间元素全部存放在内存中的排序
 * 外部排序：指在排序期间元素无法全部同时存放在内容中，必须在排序过程中根据要求不断的内、外存之间进行移动
 


## 排序算法

 ### 插入排序
  **每一步将一个待排序的元素，按其排序码的大小，插入到前面已经排好序的一组元素的适当位置上去，直到元素全部插入为止。**
  
  

时间复杂度 | 空间复杂度 | 稳定性
---|--- | ---
最好情况o(n) 最坏情况o(n~2) | o(1) | 稳定 

  * 直接插入排序
   直接插入插排的基本思想是：
  ```
      当插入第i(i >= 1)时，前面的V[0]，V[1]，……，V[i-1]已经排好序。
      用V[I]的排序码与V[i-1]，V[i-2]，…的排序码顺序进行比较，
      找到插入位置即将V[i]插入，
      原来位置上的元素向后顺移。
  ```
   
  * 折半插入排序
   二分法的思想，在一个有序的序列中，找到新元素在该序列中的位置，然后插入
   ```
    1.当插入第i个元素时候,首先查找到带排序序列的最高位置元素high和最低位置low
    2.对比当前元素和(low+high)/2时候的元素大小，如果当前元素是大于中间元素，则当前元素排序位置应该在中间元素后面，将low = (low+hign)/2
    3.反复进行2操作，直到找到合适位置，使得当前low>high,

   ``` 
  * 希尔插入排序
 ### 交换排序
  * 冒泡排序
  * 快速排序
###选择排序
   * 简单选择排序
   * 堆排序
### 归并排序
### 基数排序
